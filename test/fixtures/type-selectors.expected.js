(function() { if (!(123 == 123)) throw new Error("Assertion failed"); return true; })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pInt("123", '')), 123))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pInt("-42", '')), -42))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { try { (() => pUnwrap(pInt("abc", '')))(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })()
(function() { if (!(3.14 == 3.14)) throw new Error("Assertion failed"); return true; })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pFloat("3.14", '')), 3.14))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pFloat("-2.5", '')), -2.5))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pFloat("123", '')), 123))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { try { (() => pUnwrap(pFloat("abc", '')))(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })()
(function() { if (!(true == true)) throw new Error("Assertion failed"); return true; })()
(function() { if (!(false == false)) throw new Error("Assertion failed"); return true; })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pBool("true", '')), true))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pBool("false", '')), false))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { try { (() => pUnwrap(pBool("yes", '')))(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })()
(function() { if (!(+dayjs('2025-01-15') === +dayjs('2025-01-15'))) throw new Error("Assertion failed"); return true; })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pDate(v, p) { if (dayjs.isDayjs(v)) return pOk(v.startOf('day'), p); if (typeof v === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(v)) { const d = dayjs(v); if (d.isValid()) return pOk(d.startOf('day'), p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pDate("2025-01-15", '')), dayjs('2025-01-15')))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function pDate(v, p) { if (dayjs.isDayjs(v)) return pOk(v.startOf('day'), p); if (typeof v === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(v)) { const d = dayjs(v); if (d.isValid()) return pOk(d.startOf('day'), p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { try { (() => pUnwrap(pDate("not-a-date", '')))(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })()
(function() { if (!(+dayjs('2025-01-15T10:30:00') === +dayjs('2025-01-15T10:30:00'))) throw new Error("Assertion failed"); return true; })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pDatetime(v, p) { if (dayjs.isDayjs(v)) return pOk(v, p); if (typeof v === 'string') { const d = dayjs(v); if (d.isValid()) return pOk(d, p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pDatetime("2025-01-15T10:30:00", '')), dayjs('2025-01-15T10:30:00')))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function pDatetime(v, p) { if (dayjs.isDayjs(v)) return pOk(v, p); if (typeof v === 'string') { const d = dayjs(v); if (d.isValid()) return pOk(d, p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { try { (() => pUnwrap(pDatetime("not-a-datetime", '')))(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })()
(function() { if (!(dayjs.duration('P1D').asMilliseconds() === dayjs.duration('P1D').asMilliseconds())) throw new Error("Assertion failed"); return true; })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pDuration(v, p) { if (dayjs.isDuration(v)) return pOk(v, p); if (typeof v === 'string') { const d = dayjs.duration(v); if (!isNaN(d.asMilliseconds())) return pOk(d, p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pDuration("P1D", '')), dayjs.duration('P1D')))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pDuration(v, p) { if (dayjs.isDuration(v)) return pOk(v, p); if (typeof v === 'string') { const d = dayjs.duration(v); if (!isNaN(d.asMilliseconds())) return pOk(d, p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { if (!(kEq(pUnwrap(pDuration("PT2H30M", '')), dayjs.duration('PT2H30M')))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function pDuration(v, p) { if (dayjs.isDuration(v)) return pOk(v, p); if (typeof v === 'string') { const d = dayjs.duration(v); if (!isNaN(d.asMilliseconds())) return pOk(d, p); } return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; throw new Error('Type error at ' + (r.path || '(root)')); } return (function() { try { (() => pUnwrap(pDuration("not-a-duration", '')))(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })()

